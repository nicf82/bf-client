/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package swagger.definitions

import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import cats.implicits._
import _root_.swagger.Implicits._
case class MarketFilter(countryCodes: Option[Vector[String]] = None, bettingTypes: Option[Vector[MarketFilter.BettingTypes]] = None, turnInPlayEnabled: Option[Boolean] = None, marketTypes: Option[Vector[String]] = None, venues: Option[Vector[String]] = None, marketIds: Option[Vector[String]] = None, eventTypeIds: Option[Vector[String]] = None, eventIds: Option[Vector[String]] = None, bspMarket: Option[Boolean] = None, raceTypes: Option[Vector[String]] = None)
object MarketFilter {
  implicit val encodeMarketFilter: _root_.io.circe.Encoder.AsObject[MarketFilter] = {
    val readOnlyKeys = _root_.scala.Predef.Set[_root_.scala.Predef.String]()
    _root_.io.circe.Encoder.AsObject.instance[MarketFilter](a => _root_.io.circe.JsonObject.fromIterable(_root_.scala.Vector(("countryCodes", a.countryCodes.asJson), ("bettingTypes", a.bettingTypes.asJson), ("turnInPlayEnabled", a.turnInPlayEnabled.asJson), ("marketTypes", a.marketTypes.asJson), ("venues", a.venues.asJson), ("marketIds", a.marketIds.asJson), ("eventTypeIds", a.eventTypeIds.asJson), ("eventIds", a.eventIds.asJson), ("bspMarket", a.bspMarket.asJson), ("raceTypes", a.raceTypes.asJson)))).mapJsonObject(_.filterKeys(key => !(readOnlyKeys contains key)))
  }
  implicit val decodeMarketFilter: _root_.io.circe.Decoder[MarketFilter] = new _root_.io.circe.Decoder[MarketFilter] { final def apply(c: _root_.io.circe.HCursor): _root_.io.circe.Decoder.Result[MarketFilter] = for (v0 <- c.downField("countryCodes").as[Option[Vector[String]]]; v1 <- c.downField("bettingTypes").as[Option[Vector[MarketFilter.BettingTypes]]]; v2 <- c.downField("turnInPlayEnabled").as[Option[Boolean]]; v3 <- c.downField("marketTypes").as[Option[Vector[String]]]; v4 <- c.downField("venues").as[Option[Vector[String]]]; v5 <- c.downField("marketIds").as[Option[Vector[String]]]; v6 <- c.downField("eventTypeIds").as[Option[Vector[String]]]; v7 <- c.downField("eventIds").as[Option[Vector[String]]]; v8 <- c.downField("bspMarket").as[Option[Boolean]]; v9 <- c.downField("raceTypes").as[Option[Vector[String]]]) yield MarketFilter(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) }
  sealed abstract class BettingTypes(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object BettingTypes {
    object members {
      case object Odds extends BettingTypes("ODDS")
      case object Line extends BettingTypes("LINE")
      case object Range extends BettingTypes("RANGE")
      case object AsianHandicapDoubleLine extends BettingTypes("ASIAN_HANDICAP_DOUBLE_LINE")
      case object AsianHandicapSingleLine extends BettingTypes("ASIAN_HANDICAP_SINGLE_LINE")
    }
    val Odds: BettingTypes = members.Odds
    val Line: BettingTypes = members.Line
    val Range: BettingTypes = members.Range
    val AsianHandicapDoubleLine: BettingTypes = members.AsianHandicapDoubleLine
    val AsianHandicapSingleLine: BettingTypes = members.AsianHandicapSingleLine
    val values = _root_.scala.Vector(Odds, Line, Range, AsianHandicapDoubleLine, AsianHandicapSingleLine)
    implicit val encodeBettingTypes: _root_.io.circe.Encoder[BettingTypes] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodeBettingTypes: _root_.io.circe.Decoder[BettingTypes] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of BettingTypes"))
    implicit val showBettingTypes: Show[BettingTypes] = Show[String].contramap[BettingTypes](_.value)
    def from(value: String): _root_.scala.Option[BettingTypes] = values.find(_.value == value)
    implicit val order: cats.Order[BettingTypes] = cats.Order.by[BettingTypes, Int](values.indexOf)
  }
}