/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package swagger.definitions

import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import cats.implicits._
import _root_.swagger.Implicits._
case class MarketDataFilter(ladderLevels: Option[Int] = None, fields: Option[Vector[MarketDataFilter.Fields]] = None)
object MarketDataFilter {
  implicit val encodeMarketDataFilter: _root_.io.circe.Encoder.AsObject[MarketDataFilter] = {
    val readOnlyKeys = _root_.scala.Predef.Set[_root_.scala.Predef.String]()
    _root_.io.circe.Encoder.AsObject.instance[MarketDataFilter](a => _root_.io.circe.JsonObject.fromIterable(_root_.scala.Vector(("ladderLevels", a.ladderLevels.asJson), ("fields", a.fields.asJson)))).mapJsonObject(_.filterKeys(key => !(readOnlyKeys contains key)))
  }
  implicit val decodeMarketDataFilter: _root_.io.circe.Decoder[MarketDataFilter] = new _root_.io.circe.Decoder[MarketDataFilter] { final def apply(c: _root_.io.circe.HCursor): _root_.io.circe.Decoder.Result[MarketDataFilter] = for (v0 <- c.downField("ladderLevels").as[Option[Int]]; v1 <- c.downField("fields").as[Option[Vector[MarketDataFilter.Fields]]]) yield MarketDataFilter(v0, v1) }
  sealed abstract class Fields(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object Fields {
    object members {
      case object ExBestOffersDisp extends Fields("EX_BEST_OFFERS_DISP")
      case object ExBestOffers extends Fields("EX_BEST_OFFERS")
      case object ExAllOffers extends Fields("EX_ALL_OFFERS")
      case object ExTraded extends Fields("EX_TRADED")
      case object ExTradedVol extends Fields("EX_TRADED_VOL")
      case object ExLtp extends Fields("EX_LTP")
      case object ExMarketDef extends Fields("EX_MARKET_DEF")
      case object SpTraded extends Fields("SP_TRADED")
      case object SpProjected extends Fields("SP_PROJECTED")
    }
    val ExBestOffersDisp: Fields = members.ExBestOffersDisp
    val ExBestOffers: Fields = members.ExBestOffers
    val ExAllOffers: Fields = members.ExAllOffers
    val ExTraded: Fields = members.ExTraded
    val ExTradedVol: Fields = members.ExTradedVol
    val ExLtp: Fields = members.ExLtp
    val ExMarketDef: Fields = members.ExMarketDef
    val SpTraded: Fields = members.SpTraded
    val SpProjected: Fields = members.SpProjected
    val values = _root_.scala.Vector(ExBestOffersDisp, ExBestOffers, ExAllOffers, ExTraded, ExTradedVol, ExLtp, ExMarketDef, SpTraded, SpProjected)
    implicit val encodeFields: _root_.io.circe.Encoder[Fields] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodeFields: _root_.io.circe.Decoder[Fields] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of Fields"))
    implicit val showFields: Show[Fields] = Show[String].contramap[Fields](_.value)
    def from(value: String): _root_.scala.Option[Fields] = values.find(_.value == value)
    implicit val order: cats.Order[Fields] = cats.Order.by[Fields, Int](values.indexOf)
  }
}