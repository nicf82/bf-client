/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package swagger.definitions

import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import cats.implicits._
import _root_.swagger.Implicits._
case class Order(side: Option[Order.Side] = None, sv: Option[Double] = None, pt: Option[Order.Pt] = None, ot: Option[Order.Ot] = None, lsrc: Option[String] = None, p: Option[Double] = None, sc: Option[Double] = None, rc: Option[String] = None, s: Option[Double] = None, pd: Option[Long] = None, rac: Option[String] = None, md: Option[Long] = None, cd: Option[Long] = None, ld: Option[Long] = None, sl: Option[Double] = None, avp: Option[Double] = None, sm: Option[Double] = None, rfo: Option[String] = None, id: Option[String] = None, bsp: Option[Double] = None, rfs: Option[String] = None, status: Option[Order.Status] = None, sr: Option[Double] = None)
object Order {
  implicit val encodeOrder: _root_.io.circe.Encoder.AsObject[Order] = {
    val readOnlyKeys = _root_.scala.Predef.Set[_root_.scala.Predef.String]()
    _root_.io.circe.Encoder.AsObject.instance[Order](a => _root_.io.circe.JsonObject.fromIterable(_root_.scala.Vector(("side", a.side.asJson), ("sv", a.sv.asJson), ("pt", a.pt.asJson), ("ot", a.ot.asJson), ("lsrc", a.lsrc.asJson), ("p", a.p.asJson), ("sc", a.sc.asJson), ("rc", a.rc.asJson), ("s", a.s.asJson), ("pd", a.pd.asJson), ("rac", a.rac.asJson), ("md", a.md.asJson), ("cd", a.cd.asJson), ("ld", a.ld.asJson), ("sl", a.sl.asJson), ("avp", a.avp.asJson), ("sm", a.sm.asJson), ("rfo", a.rfo.asJson), ("id", a.id.asJson), ("bsp", a.bsp.asJson), ("rfs", a.rfs.asJson), ("status", a.status.asJson), ("sr", a.sr.asJson)))).mapJsonObject(_.filterKeys(key => !(readOnlyKeys contains key)))
  }
  implicit val decodeOrder: _root_.io.circe.Decoder[Order] = new _root_.io.circe.Decoder[Order] { final def apply(c: _root_.io.circe.HCursor): _root_.io.circe.Decoder.Result[Order] = for (v0 <- c.downField("side").as[Option[Order.Side]]; v1 <- c.downField("sv").as[Option[Double]]; v2 <- c.downField("pt").as[Option[Order.Pt]]; v3 <- c.downField("ot").as[Option[Order.Ot]]; v4 <- c.downField("lsrc").as[Option[String]]; v5 <- c.downField("p").as[Option[Double]]; v6 <- c.downField("sc").as[Option[Double]]; v7 <- c.downField("rc").as[Option[String]]; v8 <- c.downField("s").as[Option[Double]]; v9 <- c.downField("pd").as[Option[Long]]; v10 <- c.downField("rac").as[Option[String]]; v11 <- c.downField("md").as[Option[Long]]; v12 <- c.downField("cd").as[Option[Long]]; v13 <- c.downField("ld").as[Option[Long]]; v14 <- c.downField("sl").as[Option[Double]]; v15 <- c.downField("avp").as[Option[Double]]; v16 <- c.downField("sm").as[Option[Double]]; v17 <- c.downField("rfo").as[Option[String]]; v18 <- c.downField("id").as[Option[String]]; v19 <- c.downField("bsp").as[Option[Double]]; v20 <- c.downField("rfs").as[Option[String]]; v21 <- c.downField("status").as[Option[Order.Status]]; v22 <- c.downField("sr").as[Option[Double]]) yield Order(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) }
  sealed abstract class Side(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object Side {
    object members {
      case object B extends Side("B")
      case object L extends Side("L")
    }
    val B: Side = members.B
    val L: Side = members.L
    val values = _root_.scala.Vector(B, L)
    implicit val encodeSide: _root_.io.circe.Encoder[Side] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodeSide: _root_.io.circe.Decoder[Side] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of Side"))
    implicit val showSide: Show[Side] = Show[String].contramap[Side](_.value)
    def from(value: String): _root_.scala.Option[Side] = values.find(_.value == value)
    implicit val order: cats.Order[Side] = cats.Order.by[Side, Int](values.indexOf)
  }
  sealed abstract class Pt(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object Pt {
    object members {
      case object L extends Pt("L")
      case object P extends Pt("P")
      case object Moc extends Pt("MOC")
    }
    val L: Pt = members.L
    val P: Pt = members.P
    val Moc: Pt = members.Moc
    val values = _root_.scala.Vector(L, P, Moc)
    implicit val encodePt: _root_.io.circe.Encoder[Pt] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodePt: _root_.io.circe.Decoder[Pt] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of Pt"))
    implicit val showPt: Show[Pt] = Show[String].contramap[Pt](_.value)
    def from(value: String): _root_.scala.Option[Pt] = values.find(_.value == value)
    implicit val order: cats.Order[Pt] = cats.Order.by[Pt, Int](values.indexOf)
  }
  sealed abstract class Ot(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object Ot {
    object members {
      case object L extends Ot("L")
      case object Loc extends Ot("LOC")
      case object Moc extends Ot("MOC")
    }
    val L: Ot = members.L
    val Loc: Ot = members.Loc
    val Moc: Ot = members.Moc
    val values = _root_.scala.Vector(L, Loc, Moc)
    implicit val encodeOt: _root_.io.circe.Encoder[Ot] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodeOt: _root_.io.circe.Decoder[Ot] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of Ot"))
    implicit val showOt: Show[Ot] = Show[String].contramap[Ot](_.value)
    def from(value: String): _root_.scala.Option[Ot] = values.find(_.value == value)
    implicit val order: cats.Order[Ot] = cats.Order.by[Ot, Int](values.indexOf)
  }
  sealed abstract class Status(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object Status {
    object members {
      case object E extends Status("E")
      case object Ec extends Status("EC")
    }
    val E: Status = members.E
    val Ec: Status = members.Ec
    val values = _root_.scala.Vector(E, Ec)
    implicit val encodeStatus: _root_.io.circe.Encoder[Status] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodeStatus: _root_.io.circe.Decoder[Status] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of Status"))
    implicit val showStatus: Show[Status] = Show[String].contramap[Status](_.value)
    def from(value: String): _root_.scala.Option[Status] = values.find(_.value == value)
    implicit val order: cats.Order[Status] = cats.Order.by[Status, Int](values.indexOf)
  }
}