/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package swagger.definitions

import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import cats.implicits._
import _root_.swagger.Implicits._
case class StatusMessage(id: Option[Int] = None, connectionsAvailable: Option[Int] = None, errorMessage: Option[String] = None, errorCode: Option[StatusMessage.ErrorCode] = None, connectionId: Option[String] = None, connectionClosed: Option[Boolean] = None, statusCode: Option[StatusMessage.StatusCode] = None) extends ResponseMessage
object StatusMessage {
  implicit val encodeStatusMessage: _root_.io.circe.Encoder.AsObject[StatusMessage] = {
    val readOnlyKeys = _root_.scala.Predef.Set[_root_.scala.Predef.String]()
    _root_.io.circe.Encoder.AsObject.instance[StatusMessage](a => _root_.io.circe.JsonObject.fromIterable(_root_.scala.Vector(("id", a.id.asJson), ("connectionsAvailable", a.connectionsAvailable.asJson), ("errorMessage", a.errorMessage.asJson), ("errorCode", a.errorCode.asJson), ("connectionId", a.connectionId.asJson), ("connectionClosed", a.connectionClosed.asJson), ("statusCode", a.statusCode.asJson)))).mapJsonObject(_.filterKeys(key => !(readOnlyKeys contains key)))
  }
  implicit val decodeStatusMessage: _root_.io.circe.Decoder[StatusMessage] = new _root_.io.circe.Decoder[StatusMessage] { final def apply(c: _root_.io.circe.HCursor): _root_.io.circe.Decoder.Result[StatusMessage] = for (v0 <- c.downField("id").as[Option[Int]]; v1 <- c.downField("connectionsAvailable").as[Option[Int]]; v2 <- c.downField("errorMessage").as[Option[String]]; v3 <- c.downField("errorCode").as[Option[StatusMessage.ErrorCode]]; v4 <- c.downField("connectionId").as[Option[String]]; v5 <- c.downField("connectionClosed").as[Option[Boolean]]; v6 <- c.downField("statusCode").as[Option[StatusMessage.StatusCode]]) yield StatusMessage(v0, v1, v2, v3, v4, v5, v6) }
  sealed abstract class ErrorCode(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object ErrorCode {
    object members {
      case object NoAppKey extends ErrorCode("NO_APP_KEY")
      case object InvalidAppKey extends ErrorCode("INVALID_APP_KEY")
      case object NoSession extends ErrorCode("NO_SESSION")
      case object InvalidSessionInformation extends ErrorCode("INVALID_SESSION_INFORMATION")
      case object NotAuthorized extends ErrorCode("NOT_AUTHORIZED")
      case object InvalidInput extends ErrorCode("INVALID_INPUT")
      case object InvalidClock extends ErrorCode("INVALID_CLOCK")
      case object UnexpectedError extends ErrorCode("UNEXPECTED_ERROR")
      case object Timeout extends ErrorCode("TIMEOUT")
      case object SubscriptionLimitExceeded extends ErrorCode("SUBSCRIPTION_LIMIT_EXCEEDED")
      case object InvalidRequest extends ErrorCode("INVALID_REQUEST")
      case object ConnectionFailed extends ErrorCode("CONNECTION_FAILED")
      case object MaxConnectionLimitExceeded extends ErrorCode("MAX_CONNECTION_LIMIT_EXCEEDED")
      case object TooManyRequests extends ErrorCode("TOO_MANY_REQUESTS")
    }
    val NoAppKey: ErrorCode = members.NoAppKey
    val InvalidAppKey: ErrorCode = members.InvalidAppKey
    val NoSession: ErrorCode = members.NoSession
    val InvalidSessionInformation: ErrorCode = members.InvalidSessionInformation
    val NotAuthorized: ErrorCode = members.NotAuthorized
    val InvalidInput: ErrorCode = members.InvalidInput
    val InvalidClock: ErrorCode = members.InvalidClock
    val UnexpectedError: ErrorCode = members.UnexpectedError
    val Timeout: ErrorCode = members.Timeout
    val SubscriptionLimitExceeded: ErrorCode = members.SubscriptionLimitExceeded
    val InvalidRequest: ErrorCode = members.InvalidRequest
    val ConnectionFailed: ErrorCode = members.ConnectionFailed
    val MaxConnectionLimitExceeded: ErrorCode = members.MaxConnectionLimitExceeded
    val TooManyRequests: ErrorCode = members.TooManyRequests
    val values = _root_.scala.Vector(NoAppKey, InvalidAppKey, NoSession, InvalidSessionInformation, NotAuthorized, InvalidInput, InvalidClock, UnexpectedError, Timeout, SubscriptionLimitExceeded, InvalidRequest, ConnectionFailed, MaxConnectionLimitExceeded, TooManyRequests)
    implicit val encodeErrorCode: _root_.io.circe.Encoder[ErrorCode] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodeErrorCode: _root_.io.circe.Decoder[ErrorCode] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of ErrorCode"))
    implicit val showErrorCode: Show[ErrorCode] = Show[String].contramap[ErrorCode](_.value)
    def from(value: String): _root_.scala.Option[ErrorCode] = values.find(_.value == value)
    implicit val order: cats.Order[ErrorCode] = cats.Order.by[ErrorCode, Int](values.indexOf)
  }
  sealed abstract class StatusCode(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object StatusCode {
    object members {
      case object Success extends StatusCode("SUCCESS")
      case object Failure extends StatusCode("FAILURE")
    }
    val Success: StatusCode = members.Success
    val Failure: StatusCode = members.Failure
    val values = _root_.scala.Vector(Success, Failure)
    implicit val encodeStatusCode: _root_.io.circe.Encoder[StatusCode] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodeStatusCode: _root_.io.circe.Decoder[StatusCode] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of StatusCode"))
    implicit val showStatusCode: Show[StatusCode] = Show[String].contramap[StatusCode](_.value)
    def from(value: String): _root_.scala.Option[StatusCode] = values.find(_.value == value)
    implicit val order: cats.Order[StatusCode] = cats.Order.by[StatusCode, Int](values.indexOf)
  }
}