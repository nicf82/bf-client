/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package swagger.definitions

import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import cats.implicits._
import _root_.swagger.Implicits._
case class RunnerDefinition(sortPriority: Option[Int] = None, removalDate: Option[java.time.OffsetDateTime] = None, id: Option[Long] = None, hc: Option[Double] = None, adjustmentFactor: Option[Double] = None, bsp: Option[Double] = None, status: Option[RunnerDefinition.Status] = None)
object RunnerDefinition {
  implicit val encodeRunnerDefinition: _root_.io.circe.Encoder.AsObject[RunnerDefinition] = {
    val readOnlyKeys = _root_.scala.Predef.Set[_root_.scala.Predef.String]()
    _root_.io.circe.Encoder.AsObject.instance[RunnerDefinition](a => _root_.io.circe.JsonObject.fromIterable(_root_.scala.Vector(("sortPriority", a.sortPriority.asJson), ("removalDate", a.removalDate.asJson), ("id", a.id.asJson), ("hc", a.hc.asJson), ("adjustmentFactor", a.adjustmentFactor.asJson), ("bsp", a.bsp.asJson), ("status", a.status.asJson)))).mapJsonObject(_.filterKeys(key => !(readOnlyKeys contains key)))
  }
  implicit val decodeRunnerDefinition: _root_.io.circe.Decoder[RunnerDefinition] = new _root_.io.circe.Decoder[RunnerDefinition] { final def apply(c: _root_.io.circe.HCursor): _root_.io.circe.Decoder.Result[RunnerDefinition] = for (v0 <- c.downField("sortPriority").as[Option[Int]]; v1 <- c.downField("removalDate").as[Option[java.time.OffsetDateTime]]; v2 <- c.downField("id").as[Option[Long]]; v3 <- c.downField("hc").as[Option[Double]]; v4 <- c.downField("adjustmentFactor").as[Option[Double]]; v5 <- c.downField("bsp").as[Option[Double]]; v6 <- c.downField("status").as[Option[RunnerDefinition.Status]]) yield RunnerDefinition(v0, v1, v2, v3, v4, v5, v6) }
  sealed abstract class Status(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object Status {
    object members {
      case object Active extends Status("ACTIVE")
      case object Winner extends Status("WINNER")
      case object Loser extends Status("LOSER")
      case object Removed extends Status("REMOVED")
      case object RemovedVacant extends Status("REMOVED_VACANT")
      case object Hidden extends Status("HIDDEN")
      case object Placed extends Status("PLACED")
    }
    val Active: Status = members.Active
    val Winner: Status = members.Winner
    val Loser: Status = members.Loser
    val Removed: Status = members.Removed
    val RemovedVacant: Status = members.RemovedVacant
    val Hidden: Status = members.Hidden
    val Placed: Status = members.Placed
    val values = _root_.scala.Vector(Active, Winner, Loser, Removed, RemovedVacant, Hidden, Placed)
    implicit val encodeStatus: _root_.io.circe.Encoder[Status] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodeStatus: _root_.io.circe.Decoder[Status] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of Status"))
    implicit val showStatus: Show[Status] = Show[String].contramap[Status](_.value)
    def from(value: String): _root_.scala.Option[Status] = values.find(_.value == value)
    implicit val order: cats.Order[Status] = cats.Order.by[Status, Int](values.indexOf)
  }
}