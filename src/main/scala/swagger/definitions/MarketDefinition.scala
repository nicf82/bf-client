/*
 * This file was generated by guardrail (https://github.com/guardrail-dev/guardrail).
 * Modifications will be overwritten; instead edit the OpenAPI/Swagger spec file.
 */
package swagger.definitions

import cats.syntax.either._
import io.circe._
import io.circe.syntax._
import cats.implicits._
import _root_.swagger.Implicits._
case class MarketDefinition(
  venue: Option[String] = None, 
  raceType: Option[String] = None, 
  settledTime: Option[java.time.OffsetDateTime] = None, 
  timezone: Option[String] = None, 
  eachWayDivisor: Option[Double] = None, 
  regulators: Option[Vector[String]] = None, 
  marketType: Option[String] = None, 
  marketBaseRate: Option[Double] = None, 
  numberOfWinners: Option[Int] = None, 
  countryCode: Option[String] = None, 
  lineMaxUnit: Option[Double] = None, 
  inPlay: Option[Boolean] = None, 
  betDelay: Option[Int] = None, 
  bspMarket: Option[Boolean] = None, 
  bettingType: Option[MarketDefinition.BettingType] = None, 
  numberOfActiveRunners: Option[Int] = None, 
  lineMinUnit: Option[Double] = None, 
  eventId: Option[String] = None, 
  crossMatching: Option[Boolean] = None, 
  runnersVoidable: Option[Boolean] = None, 
  turnInPlayEnabled: Option[Boolean] = None, 
  priceLadderDefinition: Option[PriceLadderDefinition] = None, 
  keyLineDefinition: Option[KeyLineDefinition] = None, 
  suspendTime: Option[java.time.OffsetDateTime] = None, 
  discountAllowed: Option[Boolean] = None, 
  persistenceEnabled: Option[Boolean] = None, 
  runners: Option[_root_.scala.Vector[RunnerDefinition]] = None, 
  version: Option[Long] = None, 
  eventTypeId: Option[String] = None, 
  complete: Option[Boolean] = None, 
  openDate: Option[java.time.OffsetDateTime] = None, 
  marketTime: Option[java.time.OffsetDateTime] = None, 
  bspReconciled: Option[Boolean] = None, 
  lineInterval: Option[Double] = None, 
  status: Option[MarketDefinition.Status] = None
)
object MarketDefinition {
  implicit val encodeMarketDefinition: _root_.io.circe.Encoder.AsObject[MarketDefinition] = {
    val readOnlyKeys = _root_.scala.Predef.Set[_root_.scala.Predef.String]()
    _root_.io.circe.Encoder.AsObject.instance[MarketDefinition](a => _root_.io.circe.JsonObject.fromIterable(_root_.scala.Vector(("venue", a.venue.asJson), ("raceType", a.raceType.asJson), ("settledTime", a.settledTime.asJson), ("timezone", a.timezone.asJson), ("eachWayDivisor", a.eachWayDivisor.asJson), ("regulators", a.regulators.asJson), ("marketType", a.marketType.asJson), ("marketBaseRate", a.marketBaseRate.asJson), ("numberOfWinners", a.numberOfWinners.asJson), ("countryCode", a.countryCode.asJson), ("lineMaxUnit", a.lineMaxUnit.asJson), ("inPlay", a.inPlay.asJson), ("betDelay", a.betDelay.asJson), ("bspMarket", a.bspMarket.asJson), ("bettingType", a.bettingType.asJson), ("numberOfActiveRunners", a.numberOfActiveRunners.asJson), ("lineMinUnit", a.lineMinUnit.asJson), ("eventId", a.eventId.asJson), ("crossMatching", a.crossMatching.asJson), ("runnersVoidable", a.runnersVoidable.asJson), ("turnInPlayEnabled", a.turnInPlayEnabled.asJson), ("priceLadderDefinition", a.priceLadderDefinition.asJson), ("keyLineDefinition", a.keyLineDefinition.asJson), ("suspendTime", a.suspendTime.asJson), ("discountAllowed", a.discountAllowed.asJson), ("persistenceEnabled", a.persistenceEnabled.asJson), ("runners", a.runners.asJson), ("version", a.version.asJson), ("eventTypeId", a.eventTypeId.asJson), ("complete", a.complete.asJson), ("openDate", a.openDate.asJson), ("marketTime", a.marketTime.asJson), ("bspReconciled", a.bspReconciled.asJson), ("lineInterval", a.lineInterval.asJson), ("status", a.status.asJson)))).mapJsonObject(_.filterKeys(key => !(readOnlyKeys contains key)))
  }
  implicit val decodeMarketDefinition: _root_.io.circe.Decoder[MarketDefinition] = new _root_.io.circe.Decoder[MarketDefinition] { final def apply(c: _root_.io.circe.HCursor): _root_.io.circe.Decoder.Result[MarketDefinition] = for (v0 <- c.downField("venue").as[Option[String]]; v1 <- c.downField("raceType").as[Option[String]]; v2 <- c.downField("settledTime").as[Option[java.time.OffsetDateTime]]; v3 <- c.downField("timezone").as[Option[String]]; v4 <- c.downField("eachWayDivisor").as[Option[Double]]; v5 <- c.downField("regulators").as[Option[Vector[String]]]; v6 <- c.downField("marketType").as[Option[String]]; v7 <- c.downField("marketBaseRate").as[Option[Double]]; v8 <- c.downField("numberOfWinners").as[Option[Int]]; v9 <- c.downField("countryCode").as[Option[String]]; v10 <- c.downField("lineMaxUnit").as[Option[Double]]; v11 <- c.downField("inPlay").as[Option[Boolean]]; v12 <- c.downField("betDelay").as[Option[Int]]; v13 <- c.downField("bspMarket").as[Option[Boolean]]; v14 <- c.downField("bettingType").as[Option[MarketDefinition.BettingType]]; v15 <- c.downField("numberOfActiveRunners").as[Option[Int]]; v16 <- c.downField("lineMinUnit").as[Option[Double]]; v17 <- c.downField("eventId").as[Option[String]]; v18 <- c.downField("crossMatching").as[Option[Boolean]]; v19 <- c.downField("runnersVoidable").as[Option[Boolean]]; v20 <- c.downField("turnInPlayEnabled").as[Option[Boolean]]; v21 <- c.downField("priceLadderDefinition").as[Option[PriceLadderDefinition]]; v22 <- c.downField("keyLineDefinition").as[Option[KeyLineDefinition]]; v23 <- c.downField("suspendTime").as[Option[java.time.OffsetDateTime]]; v24 <- c.downField("discountAllowed").as[Option[Boolean]]; v25 <- c.downField("persistenceEnabled").as[Option[Boolean]]; v26 <- c.downField("runners").as[Option[_root_.scala.Vector[RunnerDefinition]]]; v27 <- c.downField("version").as[Option[Long]]; v28 <- c.downField("eventTypeId").as[Option[String]]; v29 <- c.downField("complete").as[Option[Boolean]]; v30 <- c.downField("openDate").as[Option[java.time.OffsetDateTime]]; v31 <- c.downField("marketTime").as[Option[java.time.OffsetDateTime]]; v32 <- c.downField("bspReconciled").as[Option[Boolean]]; v33 <- c.downField("lineInterval").as[Option[Double]]; v34 <- c.downField("status").as[Option[MarketDefinition.Status]]) yield MarketDefinition(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) }
  sealed abstract class BettingType(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object BettingType {
    object members {
      case object Odds extends BettingType("ODDS")
      case object Line extends BettingType("LINE")
      case object Range extends BettingType("RANGE")
      case object AsianHandicapDoubleLine extends BettingType("ASIAN_HANDICAP_DOUBLE_LINE")
      case object AsianHandicapSingleLine extends BettingType("ASIAN_HANDICAP_SINGLE_LINE")
    }
    val Odds: BettingType = members.Odds
    val Line: BettingType = members.Line
    val Range: BettingType = members.Range
    val AsianHandicapDoubleLine: BettingType = members.AsianHandicapDoubleLine
    val AsianHandicapSingleLine: BettingType = members.AsianHandicapSingleLine
    val values = _root_.scala.Vector(Odds, Line, Range, AsianHandicapDoubleLine, AsianHandicapSingleLine)
    implicit val encodeBettingType: _root_.io.circe.Encoder[BettingType] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodeBettingType: _root_.io.circe.Decoder[BettingType] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of BettingType"))
    implicit val showBettingType: Show[BettingType] = Show[String].contramap[BettingType](_.value)
    def from(value: String): _root_.scala.Option[BettingType] = values.find(_.value == value)
    implicit val order: cats.Order[BettingType] = cats.Order.by[BettingType, Int](values.indexOf)
  }
  sealed abstract class Status(val value: String) extends _root_.scala.Product with _root_.scala.Serializable { override def toString: String = value.toString }
  object Status {
    object members {
      case object Inactive extends Status("INACTIVE")
      case object Open extends Status("OPEN")
      case object Suspended extends Status("SUSPENDED")
      case object Closed extends Status("CLOSED")
    }
    val Inactive: Status = members.Inactive
    val Open: Status = members.Open
    val Suspended: Status = members.Suspended
    val Closed: Status = members.Closed
    val values = _root_.scala.Vector(Inactive, Open, Suspended, Closed)
    implicit val encodeStatus: _root_.io.circe.Encoder[Status] = _root_.io.circe.Encoder[String].contramap(_.value)
    implicit val decodeStatus: _root_.io.circe.Decoder[Status] = _root_.io.circe.Decoder[String].emap(value => from(value).toRight(s"$value not a member of Status"))
    implicit val showStatus: Show[Status] = Show[String].contramap[Status](_.value)
    def from(value: String): _root_.scala.Option[Status] = values.find(_.value == value)
    implicit val order: cats.Order[Status] = cats.Order.by[Status, Int](values.indexOf)
  }
}